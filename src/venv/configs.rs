//! Type checker configuration file generation.

use crate::chimerax::PythonInfo;
use crate::error::Result;
use std::collections::HashSet;
use std::fs;
use std::path::Path;

/// Types of configuration files that can be generated.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ConfigType {
    /// ty.toml configuration
    Ty,
    /// Ruff section in pyproject.toml
    Ruff,
    /// pyrightconfig.json
    Pyright,
    /// .vscode/settings.json
    Vscode,
}

impl ConfigType {
    /// Parse config type from string.
    pub fn parse(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "ty" => Some(Self::Ty),
            "ruff" => Some(Self::Ruff),
            "pyright" => Some(Self::Pyright),
            "vscode" => Some(Self::Vscode),
            _ => None,
        }
    }

    /// Get the default config types (ty + ruff).
    pub fn defaults() -> HashSet<Self> {
        let mut set = HashSet::new();
        set.insert(Self::Ty);
        set.insert(Self::Ruff);
        set
    }
}

/// Generator for type checker configuration files.
pub struct ConfigGenerator<'a> {
    venv_path: &'a Path,
    project_root: &'a Path,
}

impl<'a> ConfigGenerator<'a> {
    /// Create a new config generator.
    pub fn new(_python_info: &'a PythonInfo, venv_path: &'a Path, project_root: &'a Path) -> Self {
        Self {
            venv_path,
            project_root,
        }
    }

    /// Generate the specified configuration files.
    pub fn generate(&self, configs: &HashSet<ConfigType>) -> Result<Vec<String>> {
        let mut generated = Vec::new();

        for config in configs {
            match config {
                ConfigType::Ty => {
                    self.generate_ty_toml()?;
                    generated.push("ty.toml".to_string());
                }
                ConfigType::Ruff => {
                    self.generate_ruff_config()?;
                    generated.push("pyproject.toml [tool.ruff]".to_string());
                }
                ConfigType::Pyright => {
                    self.generate_pyright_config()?;
                    generated.push("pyrightconfig.json".to_string());
                }
                ConfigType::Vscode => {
                    self.generate_vscode_settings()?;
                    generated.push(".vscode/settings.json".to_string());
                }
            }
        }

        Ok(generated)
    }

    /// Generate ty.toml configuration.
    fn generate_ty_toml(&self) -> Result<()> {
        let venv_path = self.venv_path.to_string_lossy();

        let content = format!(
            r#"# ty configuration for ChimeraX bundle development
# Generated by echidna setup-ide

[environment]
python-path = "{venv_path}"
"#,
            venv_path = venv_path,
        );

        let ty_path = self.project_root.join("ty.toml");
        fs::write(&ty_path, content)?;

        Ok(())
    }

    /// Generate or update pyproject.toml with ruff configuration.
    fn generate_ruff_config(&self) -> Result<()> {
        let pyproject_path = self.project_root.join("pyproject.toml");

        // Ruff configuration section
        let venv_path = self.venv_path.to_string_lossy();
        let ruff_section = format!(
            r#"
# Ruff configuration for ChimeraX bundle development
# Generated by echidna setup-ide
[tool.ruff]
target-version = "py311"

[tool.ruff.lint.per-file-ignores]
"__init__.py" = ["F401"]  # Allow unused imports in __init__.py

[tool.ruff.lint.isort]
known-first-party = ["chimerax"]

[tool.ruff.lint]
select = ["E", "F", "I"]

[tool.ruff.analyze]
python-path = "{venv_path}"
"#,
            venv_path = venv_path,
        );

        if pyproject_path.exists() {
            // Read existing content and check if ruff section already exists
            let existing = fs::read_to_string(&pyproject_path)?;

            if existing.contains("[tool.ruff]") {
                // Already has ruff config, don't overwrite
                println!(
                    "  Note: [tool.ruff] already exists in pyproject.toml, skipping ruff config"
                );
                return Ok(());
            }

            // Append ruff configuration
            let new_content = format!("{}\n{}", existing.trim_end(), ruff_section);
            fs::write(&pyproject_path, new_content)?;
        } else {
            // Create minimal pyproject.toml with ruff config
            let content = format!(
                r#"[project]
name = "bundle"
version = "0.1.0"
{}
"#,
                ruff_section
            );
            fs::write(&pyproject_path, content)?;
        }

        Ok(())
    }

    /// Generate pyrightconfig.json.
    fn generate_pyright_config(&self) -> Result<()> {
        let venv_path = self.venv_path.to_string_lossy();

        let content = format!(
            r#"{{
  "venvPath": ".",
  "venv": "{}",
  "pythonVersion": "3.11",
  "typeCheckingMode": "basic",
  "reportMissingImports": true,
  "reportMissingTypeStubs": false
}}
"#,
            self.venv_path
                .file_name()
                .map(|n| n.to_string_lossy().to_string())
                .unwrap_or_else(|| venv_path.to_string())
        );

        let pyright_path = self.project_root.join("pyrightconfig.json");
        fs::write(&pyright_path, content)?;

        Ok(())
    }

    /// Generate .vscode/settings.json.
    fn generate_vscode_settings(&self) -> Result<()> {
        let vscode_dir = self.project_root.join(".vscode");
        fs::create_dir_all(&vscode_dir)?;

        let venv_path = self.venv_path.to_string_lossy();

        let content = format!(
            r#"{{
  "python.defaultInterpreterPath": "{venv_path}/bin/python",
  "python.analysis.typeCheckingMode": "basic",
  "python.analysis.extraPaths": [
    "{venv_path}/lib/python3.11/site-packages"
  ]
}}
"#,
            venv_path = venv_path,
        );

        let settings_path = vscode_dir.join("settings.json");

        if settings_path.exists() {
            println!("  Note: .vscode/settings.json already exists, skipping");
            return Ok(());
        }

        fs::write(&settings_path, content)?;

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_config_type_from_str() {
        assert_eq!(ConfigType::parse("ty"), Some(ConfigType::Ty));
        assert_eq!(ConfigType::parse("ruff"), Some(ConfigType::Ruff));
        assert_eq!(ConfigType::parse("pyright"), Some(ConfigType::Pyright));
        assert_eq!(ConfigType::parse("vscode"), Some(ConfigType::Vscode));
        assert_eq!(ConfigType::parse("TY"), Some(ConfigType::Ty));
        assert_eq!(ConfigType::parse("unknown"), None);
    }

    #[test]
    fn test_config_type_defaults() {
        let defaults = ConfigType::defaults();
        assert!(defaults.contains(&ConfigType::Ty));
        assert!(defaults.contains(&ConfigType::Ruff));
        assert!(!defaults.contains(&ConfigType::Pyright));
        assert!(!defaults.contains(&ConfigType::Vscode));
    }
}
