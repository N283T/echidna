//! Type checker configuration file generation.

use crate::chimerax::PythonInfo;
use crate::error::Result;
use std::collections::HashSet;
use std::fs;
use std::path::Path;

/// Types of configuration files that can be generated.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ConfigType {
    /// ty.toml configuration
    Ty,
    /// Ruff section in pyproject.toml
    Ruff,
}

impl ConfigType {
    /// Parse config type from string.
    pub fn parse(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "ty" => Some(Self::Ty),
            "ruff" => Some(Self::Ruff),
            _ => None,
        }
    }

    /// Get the default config types (ty + ruff).
    pub fn defaults() -> HashSet<Self> {
        let mut set = HashSet::new();
        set.insert(Self::Ty);
        set.insert(Self::Ruff);
        set
    }
}

/// Generator for type checker configuration files.
pub struct ConfigGenerator<'a> {
    venv_path: &'a Path,
    project_root: &'a Path,
}

impl<'a> ConfigGenerator<'a> {
    /// Create a new config generator.
    pub fn new(_python_info: &'a PythonInfo, venv_path: &'a Path, project_root: &'a Path) -> Self {
        Self {
            venv_path,
            project_root,
        }
    }

    /// Generate the specified configuration files.
    pub fn generate(&self, configs: &HashSet<ConfigType>) -> Result<Vec<String>> {
        let mut generated = Vec::new();

        for config in configs {
            match config {
                ConfigType::Ty => {
                    self.generate_ty_toml()?;
                    generated.push("ty.toml".to_string());
                }
                ConfigType::Ruff => {
                    self.generate_ruff_config()?;
                    generated.push("pyproject.toml [tool.ruff]".to_string());
                }
            }
        }

        Ok(generated)
    }

    /// Generate ty.toml configuration.
    fn generate_ty_toml(&self) -> Result<()> {
        let venv_path = self.venv_path.to_string_lossy();

        let content = format!(
            r#"# ty configuration for ChimeraX bundle development
# Generated by echidna setup-ide

[environment]
python-path = "{venv_path}"
"#,
            venv_path = venv_path,
        );

        let ty_path = self.project_root.join("ty.toml");
        fs::write(&ty_path, content)?;

        Ok(())
    }

    /// Generate or update pyproject.toml with ruff configuration.
    fn generate_ruff_config(&self) -> Result<()> {
        let pyproject_path = self.project_root.join("pyproject.toml");

        // Ruff configuration section
        let ruff_section = r#"
# Ruff configuration for ChimeraX bundle development
# Generated by echidna setup-ide
[tool.ruff]
target-version = "py311"

[tool.ruff.lint.per-file-ignores]
"__init__.py" = ["F401"]  # Allow unused imports in __init__.py

[tool.ruff.lint.isort]
known-first-party = ["chimerax"]

[tool.ruff.lint]
select = ["E", "F", "I"]
"#;

        if pyproject_path.exists() {
            // Read existing content and check if ruff section already exists
            let existing = fs::read_to_string(&pyproject_path)?;

            if existing.contains("[tool.ruff]") {
                // Already has ruff config, don't overwrite
                println!(
                    "  Note: [tool.ruff] already exists in pyproject.toml, skipping ruff config"
                );
                return Ok(());
            }

            // Append ruff configuration
            let new_content = format!("{}\n{}", existing.trim_end(), ruff_section);
            fs::write(&pyproject_path, new_content)?;
        } else {
            // Create minimal pyproject.toml with ruff config
            let content = format!(
                r#"[project]
name = "bundle"
version = "0.1.0"
{}
"#,
                ruff_section
            );
            fs::write(&pyproject_path, content)?;
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_config_type_parse() {
        assert_eq!(ConfigType::parse("ty"), Some(ConfigType::Ty));
        assert_eq!(ConfigType::parse("ruff"), Some(ConfigType::Ruff));
        assert_eq!(ConfigType::parse("TY"), Some(ConfigType::Ty));
        assert_eq!(ConfigType::parse("RUFF"), Some(ConfigType::Ruff));
        assert_eq!(ConfigType::parse("unknown"), None);
        assert_eq!(ConfigType::parse("pyright"), None);
        assert_eq!(ConfigType::parse("vscode"), None);
    }

    #[test]
    fn test_config_type_defaults() {
        let defaults = ConfigType::defaults();
        assert!(defaults.contains(&ConfigType::Ty));
        assert!(defaults.contains(&ConfigType::Ruff));
        assert_eq!(defaults.len(), 2);
    }
}
